#!/usr/bin/env node
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **

const { hideBin } = require('yargs/helpers')
const inquirer = require('inquirer')
const {readFileSync} = require('fs');
const {spawnSync} = require('child_process');
const yargs = require('yargs');
const { Octokit } = require('@octokit/rest');
const open = require('open');

yargs(hideBin(process.argv)).command('* <repo>', 'eyeball commit history of repository', yargs => {
  yargs.positional('repo', {
    describe: 'repository to list commits for, format owner/repo'
  })
}, async argv => {
  const octokit = new Octokit({
    auth: argv.token
  })
  const [owner, repo] = argv.repo.split('/')
  const commits = []
  for await (const response of octokit.paginate.iterator(
    octokit.rest.repos.listCommits,
    {
      owner,
      repo,
      since: new Date(argv.since)
    }
  )) {
    for (const commit of response.data) {
      commits.push(commit)
    }
  }
  let i = 0
  for (const commit of commits) {
    console.info(`commit ${++i} of ${commits.length}`)
    open(`https://github.com/${argv.repo}/commit/${commit.sha}`)
    const answer = await inquirer.prompt([{
      name: 'commit',
      type: 'list',
      choices: ['safe', 'suspicious']
    }])
    if (answer.commit === 'suspicious') {
      console.info(`${argv.repo} had suspicious activity, please report`)
      process.exit(1)
    }
  }
})
.command('scan-tags', 'examine release tags, ensure they point to main branch (must be run in repository)', yargs => {
  yargs.positional('repo', {
    describe: 'repository to list commits for, format owner/repo'
  })
}, async argv => {
  const octokit = new Octokit({
    auth: argv.token
  })
  const pkg = JSON.parse(readFileSync('./package.json'));
  const repository = pkg?.repository?.url ? pkg.repository.url : pkg.repository
  const [owner, repo] = repository.split('/');
  const latestGH = (await octokit.rest.repos.getLatestRelease({
    owner,
    repo,
  })).data.name.replace('v', '');
  const result = spawnSync('npm', ['dist-tag', 'ls']).stdout.toString('utf8');
  const latestNPM = result.match(/latest: (?<version>.*)/).groups.version;
  const tags = [];
  if (latestNPM !== latestGH) {
    console.info('latest version on npm does not match GitHub');
  } else {
    console.info(`gh = ${latestGH} npm = ${latestNPM}`);
  }
  for await (const response of octokit.paginate.iterator(
    octokit.rest.repos.listTags,
    {
      owner,
      repo,
    }
  )) {
    for (const tag of response.data) {
      tags.push(tag);
    }
  }
  console.info('total tags', tags.length);
  let i = 0;
  for (const tag of tags) {
    const result = spawnSync('git', ['branch', '--contains', tag.commit.sha]);
    if (result.status !== 0 || !result.stdout.toString('utf8').includes('* master')) {
      console.info(`${owner}/${repo} could not find ${tag.name} on main branch`);
    } else {
      if ((++i % 5) === 0) {
        console.info(result.stdout.toString('utf8'));
        return;
      }
    }
  }
})
  .option('since', {
    describe: 'only show commits since a given date (YYYY-MM-DD)',
    default: '2021-01-29',
    type: 'string',
    demand: true
  })
  .option('token', {
    describe: 'GitHub access token',
    type: 'string',
    demand: true
  })
  .parse()
